#[compute]
#version 450

// Invocations in the (x, y, z) dimension
layout(local_size_x = 2, local_size_y = 1, local_size_z = 1) in;

const float EPSILON = 0.00001;

struct Sheep{
    //changing values
    vec3 position;
    vec3 velocity;
    vec3 acceleration;

    float stress;
    float fear;
    float contagion;

    //constant values
    float courage;

    float view_distance;
    float fear_distance;
    float max_speed;
    float max_speed_afraid;
    float drag;

    int neighbor_count;
};

struct Predator{
    vec3 position;
    float thread_intesity;
};

layout(set = 0, binding = 0, std430) restrict buffer HerdBuffer {
    Sheep sheep[];
} herd;
uniform int herd_size;

layout(set = 0, binding = 1, std430) restrict buffer PackBuffer {
    Predator predator[];
} pack;
uniform int pack_size;

uniform float emotional_stress_mult;    // m (sigmoid multiplier)

// Herding Parameters
uniform float seperation_radius;
uniform float cohesion_mult;            // Cf
uniform float alignment_mult;           // Af
uniform float seperation_mult;          // Sf

uniform float predator_fear_mult;       // Eef
uniform float contagion_mult;

// Panicked Multipliers
uniform float cohesion_afraid_mult;   // Cef
uniform float alignment_afraid_mult;  // Aef
uniform float seperation_afraid_mult; // Sef


float emotional_stress(float d, float r, float m){
    return atan2((r - d), m) / PI + .5;
}

// float inv_sqr(float x, float s){
// 	return pow(s/(x + EPSILON), 2.);
//}

//Implementing Sheep Boids based on this paper here:
//https://www.diva-portal.org/smash/get/diva2:1354921/FULLTEXT01.pdf

void main(){
    uint boidID = gl_GlobalInvocationID.x;
    Sheep self = herd.sheep[boidID];

    for(uint i = 0; i < herd_size; i++){
        Sheep other = herd.sheep[i];
        
        if(self == other) continue;

        //Escape
        vec3 escape_vector = vec3(0.);
        float max_predator_stress = 0.;
        for(uint j = 0; j < pack_size; j++){
            Predator p = pack.predator[j];
            float dist = distance(self.position, p.position);
            if(dist < self.fear_distance){
                vec3 escape = self.position - p.position;
                float stress = emotional_stress(dist, self.fear_distance, self.courage);
                escape_vector += stress * normalize(escape);
                max_predator_stress = max(max_predator_stress, stress);
            }
        }

        //Alignment, Cohesion, and Contagion 
        vec3 alignment_vector = vec3(0.);
        vec3 cohesion_vector = vec3(0.);
        self.contagion = 0.;

        vec3 neighbor_average = vec3(0.);

        if(distance(self, other) < self.view_distance){
            self.neighbor_count++;
            alignment_vector += other.velocity;
            neighbor_average += other.position;'
            self.contagion += other.fear;
        }
        self.neighbor_count = max(1, self.neighbor_count);
        neighbor_average /= self.neighbor_count;
        alignment_vector /= self.neighbor_count;
        self.contagion /= self.neighbor_count;

        cohesion_vector = neighbor_average - sheep.position;

        //Seperation
        vec3 seperationVector = vec3(0.);
        vec3 seperation = -(other.position - self.position);
        float dist = length(seperation);
        if(dist < neighbor_radius):
			seperation_vector += (neighbor_radius - dist)/(dist+EPSILON) * seperation;
    }
		
	self.stress = predator_fear_mult * max_predator_stress + contagion_mult * escape_vector;
	
	vec3 a = vec3(0.);
	vec3 cohesion = cohesion_mult * (1. + self.stress * cohesion_afraid_mult) * cohesion_vector;
	vec3 alignment = alignment_mult * (1. + self.stress * alignment_afraid_mult) * alignment_vector;
	vec3 seperation = seperation_mult * (1. + self.stress * seperation_afraid_mult) * seperation_vector;
	vec3 evasion = self.stress * escape_vector; //ES calc is done inside escape_rule because of per predator
	
	a = (cohesion + alignment + seperation + evasion);
	a = normalize(v) * min(length(v),  (1. + sheep.stress * self.max_speed_afraid) * self.max_speed);
    self.acceleration = a;
}

